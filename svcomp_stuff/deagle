#! /usr/bin/python3

import sys
import os
import re
import time

timelimit = 890
limit_solverbound = 300

def update_result(old_result, new_result):
    if old_result == "UNKNOWN":
        return new_result
    elif old_result == "SUCCESS" and new_result == "FAILURE":
        return new_result
    else:
        return old_result

def check_unwind_ok():
    with open("deagle_tmp_output", "r") as output:
        lines = output.readlines()
        for line in lines:
            if "Unwinding successfully" in line:
                return True
    return False

def check_result_normality(lines):
    last_line = lines[-1]
    return "VERIFICATION SUCCESSFUL" in last_line or "VERIFICATION FAILED" in last_line

def get_result():
    property_result = "SUCCESS"
    unwind_result = "SUCCESS"
    with open("deagle_tmp_output", "r") as output:
        lines = output.readlines()
        if not check_result_normality(lines):
            return ("ERROR", "SUCCESS")
        for line in lines:
            obj = re.match(r"\[(.*)\](.*): (.*)", line) # is a result line
            if not obj:
                continue
            name = obj.group(1)
            result = obj.group(3)
            if ".unwind." in name:
                unwind_result = update_result(unwind_result, result)
            else:
                property_result = update_result(property_result, result)
            print(line,end="")
    print("Property: %s" % property_result)
    return (property_result, unwind_result)

def output_result(result, last_result):
    if result == "UNKNOWN" or result == "ERROR":
        result = last_result
    if result == "SUCCESS":
        print("SUCCESSFUL")
        sys.exit(0)
    elif result == "FAILURE":
        print("FAILED")
        sys.exit(0)
    else:
        print(result)
        sys.exit(1)

def get_loop_info(program_path, flags):
    cmd = "./deagle_exe %s %s --unwind-suggest > deagle_tmp_unwind_suggest 2>&1" % (program_path, flags)
    print(cmd)
    os.system(cmd)

    loops_name = []
    loops_limit = []
    is_onlystatic = True
    with open("deagle_tmp_unwind_suggest", "r") as output:
        lines = output.readlines()
        for i in range(len(lines)):
            obj = re.match(r"Loop (.+):", lines[i])
            if obj:
                loop_name = obj.group(1)
                loops_name.append(loop_name)
            
            obj = re.match(r"Suggested unwind limit: (\d+)", lines[i])
            if obj:
                loop_limit = int(obj.group(1))
                loops_limit.append(loop_limit)
                if loop_limit > limit_solverbound:
                    is_onlystatic = False
            
            obj = re.match(r"No suggested unwind limit", lines[i])
            if obj:
                loop_limit = 0
                loops_limit.append(loop_limit)
                is_onlystatic = False
            
    print(loops_name, loops_limit)
    os.system("rm deagle_tmp_unwind_suggest")
    return loops_name, loops_limit, is_onlystatic

def generate_unwindset(loops_name, loops_limit):
    unwindset = ""
    for loop_name, limit in zip(loops_name, loops_limit):
        unwindset += ("%s:%d," % (loop_name, limit))
    return unwindset

if len(sys.argv) < 2 or sys.argv[1] == "-v" or sys.argv[1] == "--version":
    print("4.0.1")
    sys.exit(0)

if sys.argv[1] == "--witness":
    print("Deagle is not a validator!")
    sys.exit(0)

if len(sys.argv) < 3:
    print("Usage: ./deagle.py property_path program_path")
    sys.exit(0)

property_path = sys.argv[1]
program_path = sys.argv[2]
# flags = "--unwinding-assertions --graphml-witness error-witness.graphml "
flags = "--allow-pointer-unsoundness --graphml-witness error-witness.graphml "

if "unreach-call.prp" in property_path:
    flags += ""
elif "no-data-race.prp" in property_path:
    flags += "--no-assertions --datarace "
elif "no-overflow.prp" in property_path:
    flags += "--no-assertions --signed-overflow-check --unsigned-overflow-check "
elif "valid-memsafety.prp" in property_path:
    flags += "--no-assertions --pointer-check --alloc-check --memory-leak-check"
else:
    print("Unknown property: %s" % property_path)
    sys.exit(0)

loops_name, loops_limit, is_onlystatic = get_loop_info(program_path, flags)

# szh: give up when loop limit is too large
for loop_limit in loops_limit:
    if loop_limit > limit_solverbound:
        print("Too large unwind limit: %d!" % loop_limit)
        sys.exit(0)

if not loops_name:
    # 若无循环，则不需要加 unwindset 参数直接调用 deagle_exe 即可
    print("No loops!")
    start_time = time.perf_counter()
    end_time = start_time + timelimit
    now = time.perf_counter()
    timeout = int(end_time - now)
    cmd = "timeout %d ./deagle_exe %s %s > deagle_tmp_output 2>&1" % (timeout, program_path, flags)
    print(cmd)
    os.system(cmd)
    property_result, unwind_result = get_result()
elif is_onlystatic:
    # 若有循环，且检测到所有循环的循环次数均都不超过一个阈值，则直接用循环次数作为展开次数调用 deagle_exe
    print("The loops is not larger than solverbound!")
    start_time = time.perf_counter()
    end_time = start_time + timelimit
    now = time.perf_counter()
    timeout = int(end_time - now)
    unwindset = generate_unwindset(loops_name, loops_limit)
    
    cmd = "timeout %d ./deagle_exe %s %s --unwindset %s > deagle_tmp_output 2>&1" % (timeout, program_path, flags, unwindset)
    print("\nUnwindset: %s, Available time: %d" % (unwindset, timeout))
    print(cmd)

    os.system(cmd)
    property_result, unwind_result = get_result()
else:
    # Try whether this is solvable without giving unwind limit
    try_cmd = "timeout 5 ./deagle_exe %s %s > deagle_tmp_output 2>&1" % (program_path, flags)
    print(try_cmd)
    os.system(try_cmd)
    try_property_result, try_unwind_result = get_result()
    if try_property_result == "SUCCESS" or try_property_result == "FAILURE":
        print("Solved within the single try!")
        os.system("rm deagle_tmp_output")
        output_result(try_property_result, try_property_result)
        sys.exit(0)
    elif check_unwind_ok():
        print("Not solved within the single try, but we find the unwind limit is not a problem")
        os.system("rm deagle_tmp_output")
        try_cmd = "timeout 885 ./deagle_exe %s %s > deagle_tmp_output 2>&1" % (program_path, flags)
        print(try_cmd)
        os.system(try_cmd)
        try_property_result, try_unwind_result = get_result()
        os.system("rm deagle_tmp_output")
        output_result(try_property_result, try_property_result)
        sys.exit(0)
    os.system("rm deagle_tmp_output")

    # 若有循环但没检测到循环次数，则多次尝试展开次数做 unwindset 参数去调用 deagle_exe 寻找反例
    print("The bound of loops is not determined!")
    
    iterations = 1
    undetermine_limits = [3]

    last_result = "UNKNOWN"
    last_unwindset = "N/A"
    start_time = time.perf_counter()
    end_time = start_time + timelimit
    for it in range(iterations):
        now = time.perf_counter()
        timeout = int(end_time - now)

        loops_limit_it = [loop_limit if loop_limit else undetermine_limits[it] for loop_limit in loops_limit]
        unwindset = generate_unwindset(loops_name, loops_limit_it)
        if unwindset == last_unwindset: # Identical to the previous unwindset, just output last result
            output_result(last_result, last_result)
        else:
            last_unwindset = unwindset

        if unwindset != "":
            cmd = "timeout %d ./deagle_exe %s %s --unwindset %s > deagle_tmp_output 2>&1" % (timeout, program_path, flags, unwindset)
        else:
            cmd = "timeout %d ./deagle_exe %s %s > deagle_tmp_output 2>&1" % (timeout, program_path, flags)
        
        print("\nUnwindset: %s, Available time: %d" % (unwindset, timeout))
        print(cmd)

        os.system(cmd)
        property_result, unwind_result = get_result()

        os.system("rm deagle_tmp_output")

        if property_result == "FAILURE" or it >= iterations - 1:
            output_result(property_result, last_result)

        now = time.perf_counter()
        if now - start_time > timelimit - 1:
            print("Nearly timeup! %fs" % (now - start_time))
            output_result(property_result, last_result)

        last_result = property_result


if property_result == "SUCCESS":
    print("SUCCESSFUL")
    sys.exit(0)
elif property_result == "FAILURE":
    print("FAILED")
    sys.exit(0)
else:
    print(property_result)
    sys.exit(1)
